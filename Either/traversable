let Traversable = ../Traversable/Type

let Applicative = ../Applicative/Type

let Either = ./Type

let Left = λ(a : Type) → λ(b : Type) → (Either a b).Left

let Right = λ(a : Type) → λ(b : Type) → (Either a b).Right

in    λ(a : Type)
    →     ./foldable a
        ∧ ./functor a
        ∧ { traverse =
                λ(f : Type → Type)
              → λ(applicative : Applicative f)
              → λ(b : Type)
              → λ(c : Type)
              → λ(g : b → f c)
              → λ(ts : Either a b)
              → merge
                  { Left = λ(l : a) → applicative.pure (Either a c) (Left a c l)
                  , Right =
                        λ(r : b)
                      → applicative.map
                          c
                          (Either a c)
                          (λ(x : c) → Right a c x)
                          (g r)
                  }
                  ts
          }
      : Traversable (Either a)
