let Applicative = ../../Applicative/Type

let Semigroup = ../../Semigroup/Type

let Either = ../Type

let Left = λ(a : Type) → λ(b : Type) → (Either a b).Left

let Right = λ(a : Type) → λ(b : Type) → (Either a b).Right

in    λ(a : Type)
    → λ(semi : Semigroup a)
    →     ../functor a
        ∧ { pure = λ(b : Type) → λ(x : b) → Right a b x
          , ap =
                λ(b : Type)
              → λ(c : Type)
              → λ(g : Either a (b → c))
              → λ(fa : Either a b)
              → merge
                  { Left =
                        λ(l : a)
                      → merge
                          { Left = λ(ll : a) → Left a c (semi.op l ll)
                          , Right = λ(_ : b) → Left a c l
                          }
                          fa
                  , Right =
                      let map = (../functor a).map

                      in  λ(f : b → c) → map b c f fa
                  }
                  g
          }
      : Applicative (Either a)
